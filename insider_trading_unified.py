#!/usr/bin/env python3
"""
Sistema Unificado de Insider Trading
Integra scraping, generaci√≥n HTML y env√≠o por Telegram
Con soporte opcional para GitHub Pages
"""

import os
import sys
import subprocess
import pandas as pd
import zipfile
from datetime import datetime
from pathlib import Path
import traceback


class InsiderTradingSystem:
    """Sistema principal que gestiona todo el flujo"""
    
    def __init__(self):
        self.csv_path = "reports/insiders_daily.csv"
        self.html_path = "reports/insiders_report_completo.html"
        self.bundle_path = "reports/insiders_bundle.zip"
        self.setup_directories()
    
    def setup_directories(self):
        """Crea los directorios necesarios"""
        os.makedirs("reports", exist_ok=True)
        os.makedirs("alerts", exist_ok=True)
        print("‚úÖ Directorios verificados")
    
    def run_scraper(self):
        """Ejecuta el scraper de OpenInsider"""
        print("\nüï∑Ô∏è EJECUTANDO SCRAPER")
        print("=" * 50)
        
        try:
            # Buscar el scraper
            scraper_paths = [
                "insiders/openinsider_scraper.py",
                "openinsider_scraper.py",
                "paste-3.txt"  # Por si est√° como texto
            ]
            
            scraper_found = None
            for path in scraper_paths:
                if os.path.exists(path):
                    scraper_found = path
                    break
            
            if not scraper_found:
                print("‚ùå Scraper no encontrado")
                return False
            
            print(f"‚úÖ Ejecutando: {scraper_found}")
            
            # Si es paste-3.txt, ejecutarlo como Python
            if scraper_found.endswith('.txt'):
                with open(scraper_found, 'r') as f:
                    exec(f.read())
            else:
                result = subprocess.run(
                    [sys.executable, scraper_found],
                    capture_output=True,
                    text=True,
                    timeout=180
                )
                
                if result.returncode != 0:
                    print(f"‚ùå Error ejecutando scraper: {result.stderr}")
                    return False
            
            # Verificar que se gener√≥ el CSV
            if os.path.exists(self.csv_path):
                df = pd.read_csv(self.csv_path)
                print(f"‚úÖ CSV generado: {len(df)} registros")
                return True
            else:
                print("‚ùå CSV no generado")
                return False
                
        except Exception as e:
            print(f"‚ùå Error en scraper: {e}")
            traceback.print_exc()
            return False
    
    def generate_html(self):
        """Genera el HTML con los datos del CSV"""
        print("\nüìÑ GENERANDO HTML")
        print("=" * 50)
        
        try:
            # Verificar CSV
            if not os.path.exists(self.csv_path):
                print("‚ùå CSV no encontrado")
                return False
            
            # Importar funci√≥n de generaci√≥n
            try:
                from alerts.plot_utils import crear_html_moderno_finviz
                self.html_path = crear_html_moderno_finviz()
                return self.html_path is not None
            except ImportError:
                print("‚ö†Ô∏è plot_utils no disponible, generando HTML b√°sico")
                return self.generate_basic_html()
                
        except Exception as e:
            print(f"‚ùå Error generando HTML: {e}")
            return False
    
    def generate_basic_html(self):
        """Genera un HTML b√°sico si plot_utils no est√° disponible"""
        try:
            df = pd.read_csv(self.csv_path)
            
            html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Insider Trading Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        h1 {{ color: #333; }}
        table {{ border-collapse: collapse; width: 100%; }}
        th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
        th {{ background-color: #4CAF50; color: white; }}
        tr:nth-child(even) {{ background-color: #f2f2f2; }}
    </style>
</head>
<body>
    <h1>üìä Insider Trading Report - {datetime.now().strftime('%Y-%m-%d %H:%M')}</h1>
    <p>Total transacciones: {len(df)}</p>
    <p>Empresas √∫nicas: {df['Insider'].nunique() if 'Insider' in df.columns else 0}</p>
    
    <table>
        <tr>
            <th>Ticker</th>
            <th>Company</th>
            <th>Price</th>
            <th>Qty</th>
            <th>Value</th>
            <th>Type</th>
        </tr>
"""
            
            for _, row in df.head(50).iterrows():
                html_content += f"""
        <tr>
            <td>{row.get('Insider', 'N/A')}</td>
            <td>{row.get('Title', 'N/A')}</td>
            <td>{row.get('Price', 'N/A')}</td>
            <td>{row.get('Qty', 'N/A')}</td>
            <td>{row.get('Value', 'N/A')}</td>
            <td>{row.get('Type', 'N/A')}</td>
        </tr>
"""
            
            html_content += """
    </table>
</body>
</html>
"""
            
            with open(self.html_path, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            print(f"‚úÖ HTML b√°sico generado: {self.html_path}")
            return True
            
        except Exception as e:
            print(f"‚ùå Error generando HTML b√°sico: {e}")
            return False
    
    def create_bundle(self):
        """Crea un ZIP con todos los archivos"""
        print("\nüì¶ CREANDO BUNDLE")
        print("=" * 50)
        
        try:
            with zipfile.ZipFile(self.bundle_path, 'w') as zipf:
                if os.path.exists(self.html_path):
                    zipf.write(self.html_path, arcname=os.path.basename(self.html_path))
                if os.path.exists(self.csv_path):
                    zipf.write(self.csv_path, arcname=os.path.basename(self.csv_path))
            
            print(f"‚úÖ Bundle creado: {self.bundle_path}")
            return True
            
        except Exception as e:
            print(f"‚ùå Error creando bundle: {e}")
            return False
    
    def send_telegram(self):
        """Env√≠a reporte por Telegram"""
        print("\nüì± ENVIANDO POR TELEGRAM")
        print("=" * 50)
        
        try:
            # Intentar importar configuraci√≥n
            try:
                from config import TELEGRAM_CHAT_ID, TELEGRAM_BOT_TOKEN
            except ImportError:
                print("‚ùå config.py no encontrado")
                return False
            
            if not TELEGRAM_CHAT_ID or not TELEGRAM_BOT_TOKEN:
                print("‚ùå Configuraci√≥n Telegram incompleta")
                return False
            
            # Importar utilidades de Telegram
            try:
                from alerts.telegram_utils import send_message, send_file
            except ImportError:
                print("‚ùå telegram_utils no encontrado")
                return False
            
            # Leer estad√≠sticas
            df = pd.read_csv(self.csv_path)
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M')
            
            # Crear mensaje
            mensaje = f"""üìä REPORTE INSIDER TRADING

üìÖ Fecha: {timestamp}
üìä Transacciones: {len(df)}
üè¢ Empresas: {df['Insider'].nunique() if 'Insider' in df.columns else 0}

üìÑ Archivos adjuntos:"""
            
            # Enviar mensaje
            send_message(TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, mensaje)
            
            # Enviar archivos
            if os.path.exists(self.html_path):
                send_file(TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, self.html_path)
            
            if os.path.exists(self.csv_path):
                send_file(TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, self.csv_path)
            
            print("‚úÖ Enviado por Telegram")
            return True
            
        except Exception as e:
            print(f"‚ùå Error enviando por Telegram: {e}")
            traceback.print_exc()
            return False
    
    def upload_github_pages(self):
        """Intenta subir a GitHub Pages si est√° disponible"""
        print("\nüåê SUBIENDO A GITHUB PAGES")
        print("=" * 50)
        
        try:
            # Verificar si existe el m√≥dulo
            if not os.path.exists("github_pages_historial.py"):
                print("‚ö†Ô∏è github_pages_historial.py no encontrado")
                print("   GitHub Pages no disponible")
                return None
            
            # Intentar importar
            try:
                from github_pages_historial import GitHubPagesHistoricalUploader
            except ImportError as e:
                print(f"‚ùå Error importando: {e}")
                return None
            
            # Crear uploader
            uploader = GitHubPagesHistoricalUploader()
            
            # Preparar datos
            df = pd.read_csv(self.csv_path)
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M')
            
            if len(df) > 0:
                title = f"üìä Insider Trading - {len(df)} oportunidades - {timestamp}"
                description = f"Reporte con {len(df)} transacciones detectadas"
            else:
                title = f"üìä Monitoreo Insider Trading - {timestamp}"
                description = "Monitoreo completado sin oportunidades"
            
            # Subir
            result = uploader.upload_historical_report(
                self.html_path,
                self.csv_path,
                title,
                description
            )
            
            if result:
                print(f"‚úÖ Subido a GitHub Pages:")
                for key, value in result.items():
                    print(f"   {key}: {value}")
                return result
            else:
                print("‚ùå Error subiendo a GitHub Pages")
                return None
                
        except Exception as e:
            print(f"‚ùå Error con GitHub Pages: {e}")
            traceback.print_exc()
            return None
    
    def run_complete_process(self):
        """Ejecuta el proceso completo"""
        print("\nüöÄ PROCESO COMPLETO INSIDER TRADING")
        print("=" * 60)
        print(f"üìÖ Inicio: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        results = {
            'scraper': False,
            'html': False,
            'bundle': False,
            'telegram': False,
            'github': None
        }
        
        try:
            # 1. Ejecutar scraper
            results['scraper'] = self.run_scraper()
            if not results['scraper']:
                print("‚ùå Fallo en scraper, abortando")
                return results
            
            # 2. Generar HTML
            results['html'] = self.generate_html()
            if not results['html']:
                print("‚ö†Ô∏è Fallo en HTML, continuando...")
            
            # 3. Crear bundle
            results['bundle'] = self.create_bundle()
            
            # 4. GitHub Pages (opcional)
            results['github'] = self.upload_github_pages()
            
            # 5. Telegram
            results['telegram'] = self.send_telegram()
            
            # Resumen
            print("\n" + "=" * 60)
            print("üìä RESUMEN DE EJECUCI√ìN")
            print("=" * 60)
            print(f"‚úÖ Scraper: {'‚úì' if results['scraper'] else '‚úó'}")
            print(f"‚úÖ HTML: {'‚úì' if results['html'] else '‚úó'}")
            print(f"‚úÖ Bundle: {'‚úì' if results['bundle'] else '‚úó'}")
            print(f"‚úÖ Telegram: {'‚úì' if results['telegram'] else '‚úó'}")
            print(f"‚úÖ GitHub Pages: {'‚úì' if results['github'] else '‚úó (opcional)'}")
            
            if results['github']:
                print(f"\nüåê Ver en GitHub Pages:")
                print(f"   {results['github'].get('index_url', 'N/A')}")
            
            return results
            
        except Exception as e:
            print(f"\n‚ùå Error cr√≠tico: {e}")
            traceback.print_exc()
            return results


def test_components():
    """Prueba cada componente individualmente"""
    print("\nüîß MODO TEST - VERIFICANDO COMPONENTES")
    print("=" * 60)
    
    # 1. Verificar archivos necesarios
    print("\nüìÅ Verificando archivos:")
    files_to_check = [
        ("Scraper", ["insiders/openinsider_scraper.py", "openinsider_scraper.py", "paste-3.txt"]),
        ("Plot Utils", ["alerts/plot_utils.py", "paste-2.txt"]),
        ("Config", ["config.py"]),
        ("Telegram Utils", ["alerts/telegram_utils.py"]),
        ("GitHub Pages", ["github_pages_historial.py"])
    ]
    
    for name, paths in files_to_check:
        found = False
        for path in paths:
            if os.path.exists(path):
                print(f"‚úÖ {name}: {path}")
                found = True
                break
        if not found:
            print(f"‚ùå {name}: NO ENCONTRADO")
    
    # 2. Verificar CSV existente
    print("\nüìä Verificando datos:")
    if os.path.exists("reports/insiders_daily.csv"):
        try:
            df = pd.read_csv("reports/insiders_daily.csv")
            print(f"‚úÖ CSV existente: {len(df)} registros")
        except Exception as e:
            print(f"‚ùå CSV corrupto: {e}")
    else:
        print("‚ùå CSV no existe")
    
    # 3. Verificar configuraci√≥n Telegram
    print("\nüì± Verificando Telegram:")
    try:
        from config import TELEGRAM_CHAT_ID, TELEGRAM_BOT_TOKEN
        if TELEGRAM_CHAT_ID and TELEGRAM_BOT_TOKEN:
            print(f"‚úÖ Chat ID: {TELEGRAM_CHAT_ID}")
            print(f"‚úÖ Token: {TELEGRAM_BOT_TOKEN[:10]}...")
        else:
            print("‚ùå Configuraci√≥n incompleta")
    except ImportError:
        print("‚ùå config.py no importable")


def main():
    """Funci√≥n principal con men√∫"""
    if len(sys.argv) > 1:
        # Modo autom√°tico
        if sys.argv[1] == "--auto":
            system = InsiderTradingSystem()
            system.run_complete_process()
        elif sys.argv[1] == "--test":
            test_components()
        elif sys.argv[1] == "--scraper":
            system = InsiderTradingSystem()
            system.run_scraper()
        elif sys.argv[1] == "--html":
            system = InsiderTradingSystem()
            system.generate_html()
        elif sys.argv[1] == "--telegram":
            system = InsiderTradingSystem()
            system.send_telegram()
    else:
        # Modo interactivo
        while True:
            print("\n" + "=" * 60)
            print("üìä SISTEMA INSIDER TRADING - MEN√ö PRINCIPAL")
            print("=" * 60)
            print("1. üöÄ Ejecutar proceso completo")
            print("2. üï∑Ô∏è  Solo ejecutar scraper")
            print("3. üìÑ Solo generar HTML")
            print("4. üì± Solo enviar Telegram")
            print("5. üîß Verificar componentes")
            print("6. üåê Probar GitHub Pages")
            print("0. ‚ùå Salir")
            print("=" * 60)
            
            opcion = input("Selecciona opci√≥n: ").strip()
            
            system = InsiderTradingSystem()
            
            if opcion == "1":
                system.run_complete_process()
            elif opcion == "2":
                system.run_scraper()
            elif opcion == "3":
                system.generate_html()
            elif opcion == "4":
                system.send_telegram()
            elif opcion == "5":
                test_components()
            elif opcion == "6":
                result = system.upload_github_pages()
                if result:
                    print("‚úÖ GitHub Pages funcionando")
                else:
                    print("‚ùå GitHub Pages no disponible")
            elif opcion == "0":
                print("üëã ¬°Hasta luego!")
                break
            else:
                print("‚ùå Opci√≥n inv√°lida")
            
            input("\nPresiona Enter para continuar...")


if __name__ == "__main__":
    main()
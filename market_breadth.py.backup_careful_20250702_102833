#!/usr/bin/env python3
"""
Market Breadth Analyzer - Integraci√≥n con Sistema Trading Unificado
A√±ade an√°lisis de amplitud de mercado con dise√±o Liquid Glass
"""

import pandas as pd
import numpy as np
import requests
import yfinance as yf
from datetime import datetime, timedelta
import time
import json
import os
from pathlib import Path
import traceback

class MarketBreadthAnalyzer:
    """
    Analizador de amplitud de mercado integrado al sistema principal
    Utiliza datos de Yahoo Finance para calcular indicadores de breadth
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        
        # S√≠mbolos para an√°lisis de amplitud
        self.market_symbols = {
            'SPY': 'S&P 500 ETF',
            'QQQ': 'NASDAQ 100 ETF', 
            'DIA': 'Dow Jones ETF',
            'IWM': 'Russell 2000 ETF',
            'VTI': 'Total Stock Market ETF'
        }
        
        # Sectores para diversificaci√≥n
        self.sector_etfs = {
            'XLY': 'Consumer Discretionary',
            'XLP': 'Consumer Staples', 
            'XLE': 'Energy',
            'XLF': 'Financials',
            'XLV': 'Health Care',
            'XLI': 'Industrials',
            'XLB': 'Materials',
            'XLRE': 'Real Estate',
            'XLK': 'Technology',
            'XLC': 'Communication',
            'XLU': 'Utilities'
        }
        
        # Datos simulados de NYSE/NASDAQ para breadth
        self.breadth_data = {}
        
    def get_market_data(self, symbol, period='3mo'):
        """Obtiene datos de mercado usando yfinance"""
        try:
            ticker = yf.Ticker(symbol)
            data = ticker.history(period=period)
            
            if data.empty:
                print(f"‚ö†Ô∏è Sin datos para {symbol}")
                return None
                
            return data
            
        except Exception as e:
            print(f"‚ùå Error obteniendo datos para {symbol}: {e}")
            return None
    
    def simulate_breadth_data(self, days=60):
        """
        Simula datos de amplitud de mercado realistas
        En producci√≥n, estos vendr√≠an de una fuente de datos real
        """
        dates = pd.date_range(end=datetime.now(), periods=days, freq='D')
        dates = [d for d in dates if d.weekday() < 5]  # Solo d√≠as laborables
        
        breadth_data = {
            'dates': [d.strftime('%Y-%m-%d') for d in dates],
            'advancing': [],
            'declining': [],
            'advancing_volume': [],
            'declining_volume': [],
            'new_highs': [],
            'new_lows': [],
            'nyse_total': 3000,  # Aproximado
            'nasdaq_total': 3500
        }
        
        # Simular tendencia del mercado
        market_trend = np.random.choice([-1, 0, 1], p=[0.3, 0.2, 0.5])  # Sesgo alcista
        momentum = 0
        
        for i, date in enumerate(dates):
            # Evoluci√≥n del momentum
            if np.random.random() < 0.1:  # Cambio de tendencia 10%
                market_trend *= -1
            
            momentum += market_trend * 0.1 + np.random.normal(0, 0.5)
            momentum = np.clip(momentum, -2, 2)
            
            # Calcular advancing/declining basado en momentum
            base_advancing = 1500 + momentum * 300 + np.random.normal(0, 200)
            base_declining = 3000 - base_advancing + np.random.normal(0, 100)
            
            advancing = max(100, min(2800, int(base_advancing)))
            declining = max(100, min(2800, int(base_declining)))
            
            breadth_data['advancing'].append(advancing)
            breadth_data['declining'].append(declining)
            
            # Volumen correlacionado con movimiento
            vol_multiplier = 1 + abs(momentum) * 0.3
            adv_vol = int(advancing * 1000000 * vol_multiplier * (0.8 + np.random.random() * 0.4))
            dec_vol = int(declining * 1000000 * vol_multiplier * (0.8 + np.random.random() * 0.4))
            
            breadth_data['advancing_volume'].append(adv_vol)
            breadth_data['declining_volume'].append(dec_vol)
            
            # New highs/lows
            nh = max(0, int(10 + momentum * 20 + np.random.normal(0, 15)))
            nl = max(0, int(10 - momentum * 20 + np.random.normal(0, 15)))
            
            breadth_data['new_highs'].append(nh)
            breadth_data['new_lows'].append(nl)
        
        return breadth_data
    
    def calculate_breadth_indicators(self, breadth_data):
        """Calcula todos los indicadores de amplitud"""
        try:
            advancing = np.array(breadth_data['advancing'])
            declining = np.array(breadth_data['declining'])
            adv_volume = np.array(breadth_data['advancing_volume'])
            dec_volume = np.array(breadth_data['declining_volume'])
            new_highs = np.array(breadth_data['new_highs'])
            new_lows = np.array(breadth_data['new_lows'])
            
            # 1. A/D Line (Advance-Decline Line)
            ad_line = np.cumsum(advancing - declining)
            
            # 2. McClellan Oscillator
            net_advances = advancing - declining
            ema_19 = self._calculate_ema(net_advances, 19)
            ema_39 = self._calculate_ema(net_advances, 39)
            mcclellan = ema_19 - ema_39
            
            # 3. TRIN (Arms Index)
            trin = []
            for i in range(len(advancing)):
                if declining[i] > 0 and dec_volume[i] > 0:
                    ad_ratio = advancing[i] / declining[i]
                    vol_ratio = adv_volume[i] / dec_volume[i]
                    trin_val = ad_ratio / vol_ratio if vol_ratio > 0 else 1.0
                    trin.append(min(3.0, max(0.1, trin_val)))  # Limitar valores extremos
                else:
                    trin.append(1.0)
            
            # 4. % Stocks above MA50 (simulado)
            ma50_percent = []
            for i in range(len(advancing)):
                total = advancing[i] + declining[i]
                if total > 0:
                    pct = (advancing[i] / total) * 100
                    # A√±adir algo de variaci√≥n realista
                    pct += np.random.normal(0, 15)
                    ma50_percent.append(max(0, min(100, pct)))
                else:
                    ma50_percent.append(50)
            
            # 5. New Highs - New Lows
            nh_nl_diff = new_highs - new_lows
            
            # 6. Volume Ratio (Up Volume / Down Volume)
            volume_ratio = []
            for i in range(len(adv_volume)):
                if dec_volume[i] > 0:
                    ratio = adv_volume[i] / dec_volume[i]
                    volume_ratio.append(min(5.0, max(0.1, ratio)))
                else:
                    volume_ratio.append(2.0)
            
            # 7. Summation Index (McClellan Summation)
            summation_index = np.cumsum(mcclellan)
            
            # 8. High-Low Index
            hl_index = []
            for i in range(len(new_highs)):
                total_hl = new_highs[i] + new_lows[i]
                if total_hl > 0:
                    hl_idx = (new_highs[i] / total_hl) * 100
                    hl_index.append(hl_idx)
                else:
                    hl_index.append(50)
            
            return {
                'ad_line': ad_line.tolist(),
                'mcclellan': mcclellan.tolist(),
                'trin': trin,
                'ma50_percent': ma50_percent,
                'nh_nl_diff': nh_nl_diff.tolist(),
                'volume_ratio': volume_ratio,
                'summation_index': summation_index.tolist(),
                'hl_index': hl_index,
                'advancing': advancing.tolist(),
                'declining': declining.tolist(),
                'new_highs': new_highs.tolist(),
                'new_lows': new_lows.tolist()
            }
            
        except Exception as e:
            print(f"‚ùå Error calculando indicadores: {e}")
            return None
    
    def _calculate_ema(self, data, period):
        """Calcula EMA (Exponential Moving Average)"""
        alpha = 2 / (period + 1)
        ema = np.zeros_like(data, dtype=float)
        ema[0] = data[0]
        
        for i in range(1, len(data)):
            ema[i] = alpha * data[i] + (1 - alpha) * ema[i-1]
        
        return ema
    
    def analyze_breadth_signals(self, indicators):
        """Analiza los indicadores para generar se√±ales"""
        signals = {}
        
        try:
            # Valores actuales (√∫ltimos)
            current = {key: val[-1] if val else 0 for key, val in indicators.items()}
            
            # A/D Line se√±al
            ad_trend = "Alcista" if len(indicators['ad_line']) > 5 and indicators['ad_line'][-1] > indicators['ad_line'][-5] else "Bajista"
            signals['ad_line'] = {
                'value': current['ad_line'],
                'signal': ad_trend,
                'strength': 'Fuerte' if abs(current['ad_line']) > 1000 else 'Moderada'
            }
            
            # McClellan Oscillator se√±al
            mcc_val = current['mcclellan']
            if mcc_val > 100:
                mcc_signal = "Sobrecompra"
                mcc_strength = "Alta"
            elif mcc_val < -100:
                mcc_signal = "Sobreventa" 
                mcc_strength = "Alta"
            elif mcc_val > 50:
                mcc_signal = "Alcista"
                mcc_strength = "Moderada"
            elif mcc_val < -50:
                mcc_signal = "Bajista"
                mcc_strength = "Moderada"
            else:
                mcc_signal = "Neutral"
                mcc_strength = "Baja"
            
            signals['mcclellan'] = {
                'value': mcc_val,
                'signal': mcc_signal,
                'strength': mcc_strength
            }
            
            # TRIN se√±al
            trin_val = current['trin']
            if trin_val < 0.8:
                trin_signal = "Presi√≥n Compradora"
                trin_strength = "Fuerte" if trin_val < 0.6 else "Moderada"
            elif trin_val > 1.2:
                trin_signal = "Presi√≥n Vendedora"
                trin_strength = "Fuerte" if trin_val > 1.5 else "Moderada"
            else:
                trin_signal = "Equilibrado"
                trin_strength = "Neutral"
            
            signals['trin'] = {
                'value': trin_val,
                'signal': trin_signal,
                'strength': trin_strength
            }
            
            # % Stocks above MA50 se√±al
            ma50_val = current['ma50_percent']
            if ma50_val > 70:
                ma50_signal = "Mercado Fuerte"
                ma50_strength = "Alta"
            elif ma50_val < 30:
                ma50_signal = "Mercado D√©bil"
                ma50_strength = "Alta"
            elif ma50_val > 60:
                ma50_signal = "Tendencia Alcista"
                ma50_strength = "Moderada"
            elif ma50_val < 40:
                ma50_signal = "Tendencia Bajista"
                ma50_strength = "Moderada"
            else:
                ma50_signal = "Neutral"
                ma50_strength = "Baja"
            
            signals['ma50_percent'] = {
                'value': ma50_val,
                'signal': ma50_signal,
                'strength': ma50_strength
            }
            
            # New Highs - New Lows se√±al
            nh_nl_val = current['nh_nl_diff']
            if nh_nl_val > 50:
                nh_nl_signal = "Fortaleza Amplia"
                nh_nl_strength = "Alta"
            elif nh_nl_val < -50:
                nh_nl_signal = "Debilidad Amplia"
                nh_nl_strength = "Alta"
            elif nh_nl_val > 20:
                nh_nl_signal = "Fortaleza Moderada"
                nh_nl_strength = "Moderada"
            elif nh_nl_val < -20:
                nh_nl_signal = "Debilidad Moderada"
                nh_nl_strength = "Moderada"
            else:
                nh_nl_signal = "Neutral"
                nh_nl_strength = "Baja"
            
            signals['nh_nl_diff'] = {
                'value': nh_nl_val,
                'signal': nh_nl_signal,
                'strength': nh_nl_strength
            }
            
            # Volume Ratio se√±al
            vol_ratio_val = current['volume_ratio']
            if vol_ratio_val > 2.0:
                vol_signal = "Demanda Fuerte"
                vol_strength = "Alta"
            elif vol_ratio_val < 0.5:
                vol_signal = "Oferta Fuerte"
                vol_strength = "Alta"
            elif vol_ratio_val > 1.5:
                vol_signal = "Demanda Moderada"
                vol_strength = "Moderada"
            elif vol_ratio_val < 0.7:
                vol_signal = "Oferta Moderada"
                vol_strength = "Moderada"
            else:
                vol_signal = "Equilibrado"
                vol_strength = "Neutral"
            
            signals['volume_ratio'] = {
                'value': vol_ratio_val,
                'signal': vol_signal,
                'strength': vol_strength
            }
            
            return signals
            
        except Exception as e:
            print(f"‚ùå Error analizando se√±ales: {e}")
            return {}
    
    def generate_market_breadth_summary(self, signals):
        """Genera resumen general del mercado"""
        try:
            # Contar se√±ales alcistas vs bajistas
            bullish_signals = 0
            bearish_signals = 0
            neutral_signals = 0
            
            strength_score = 0
            total_indicators = len(signals)
            
            for indicator, signal_data in signals.items():
                signal = signal_data['signal'].lower()
                strength = signal_data['strength'].lower()
                
                # Clasificar se√±al
                if any(word in signal for word in ['alcista', 'fuerte', 'compradora', 'demanda', 'fortaleza']):
                    bullish_signals += 1
                    if strength == 'alta':
                        strength_score += 3
                    elif strength == 'moderada':
                        strength_score += 2
                    else:
                        strength_score += 1
                elif any(word in signal for word in ['bajista', 'd√©bil', 'vendedora', 'oferta', 'debilidad']):
                    bearish_signals += 1
                    if strength == 'alta':
                        strength_score -= 3
                    elif strength == 'moderada':
                        strength_score -= 2
                    else:
                        strength_score -= 1
                else:
                    neutral_signals += 1
            
            # Determinar sesgo general
            if bullish_signals > bearish_signals + 1:
                market_bias = "üü¢ ALCISTA"
                bias_emoji = "üöÄ"
                confidence = "Alta" if strength_score > 5 else "Moderada"
            elif bearish_signals > bullish_signals + 1:
                market_bias = "üî¥ BAJISTA"
                bias_emoji = "üìâ"
                confidence = "Alta" if strength_score < -5 else "Moderada"
            else:
                market_bias = "üü° NEUTRAL"
                bias_emoji = "‚öñÔ∏è"
                confidence = "Baja"
            
            return {
                'market_bias': market_bias,
                'bias_emoji': bias_emoji,
                'confidence': confidence,
                'bullish_signals': bullish_signals,
                'bearish_signals': bearish_signals,
                'neutral_signals': neutral_signals,
                'strength_score': strength_score,
                'total_indicators': total_indicators
            }
            
        except Exception as e:
            print(f"‚ùå Error generando resumen: {e}")
            return {
                'market_bias': "üü° UNKNOWN",
                'bias_emoji': "‚ùì",
                'confidence': "Baja",
                'bullish_signals': 0,
                'bearish_signals': 0,
                'neutral_signals': 0,
                'strength_score': 0,
                'total_indicators': 0
            }
    
    def run_breadth_analysis(self):
        """Ejecuta an√°lisis completo de amplitud de mercado"""
        print("\nüìä INICIANDO AN√ÅLISIS DE AMPLITUD DE MERCADO")
        print("=" * 60)
        
        try:
            # 1. Obtener/simular datos de breadth
            print("üîÑ Generando datos de amplitud...")
            breadth_data = self.simulate_breadth_data(60)
            
            # 2. Calcular indicadores
            print("üìà Calculando indicadores t√©cnicos...")
            indicators = self.calculate_breadth_indicators(breadth_data)
            
            if not indicators:
                print("‚ùå Error calculando indicadores")
                return None
            
            # 3. Analizar se√±ales
            print("üéØ Analizando se√±ales de trading...")
            signals = self.analyze_breadth_signals(indicators)
            
            # 4. Generar resumen
            print("üìã Generando resumen de mercado...")
            summary = self.generate_market_breadth_summary(signals)
            
            # 5. Preparar resultado completo
            result = {
                'breadth_data': breadth_data,
                'indicators': indicators,
                'signals': signals,
                'summary': summary,
                'timestamp': datetime.now().isoformat(),
                'analysis_date': datetime.now().strftime('%Y-%m-%d'),
                'analysis_time': datetime.now().strftime('%H:%M:%S')
            }
            
            # 6. Mostrar resumen en consola
            self._print_console_summary(summary, signals)
            
            print(f"\n‚úÖ AN√ÅLISIS COMPLETADO - {summary['market_bias']}")
            
            return result
            
        except Exception as e:
            print(f"‚ùå Error en an√°lisis de amplitud: {e}")
            traceback.print_exc()
            return None
    
    def _print_console_summary(self, summary, signals):
        """Imprime resumen en consola"""
        print(f"\nüìä RESUMEN DE AMPLITUD DE MERCADO")
        print("=" * 50)
        print(f"{summary['bias_emoji']} Sesgo General: {summary['market_bias']}")
        print(f"üéØ Confianza: {summary['confidence']}")
        print(f"üìà Se√±ales Alcistas: {summary['bullish_signals']}")
        print(f"üìâ Se√±ales Bajistas: {summary['bearish_signals']}")
        print(f"‚öñÔ∏è Se√±ales Neutrales: {summary['neutral_signals']}")
        print(f"üí™ Puntuaci√≥n Fuerza: {summary['strength_score']}")
        
        print(f"\nüîç INDICADORES CLAVE:")
        for indicator, signal_data in signals.items():
            emoji = "üü¢" if any(word in signal_data['signal'].lower() for word in ['alcista', 'fuerte', 'compradora']) else \
                   "üî¥" if any(word in signal_data['signal'].lower() for word in ['bajista', 'd√©bil', 'vendedora']) else "üü°"
            print(f"   {emoji} {indicator.upper()}: {signal_data['signal']} ({signal_data['strength']})")
    
    def save_to_csv(self, analysis_result):
        """Guarda an√°lisis en CSV"""
        try:
            if not analysis_result:
                return None
            
            # Preparar datos para CSV
            dates = analysis_result['breadth_data']['dates']
            indicators = analysis_result['indicators']
            signals = analysis_result['signals']
            
            csv_data = []
            for i, date in enumerate(dates):
                row = {
                    'Date': date,
                    'AD_Line': indicators['ad_line'][i],
                    'McClellan': indicators['mcclellan'][i],
                    'TRIN': indicators['trin'][i],
                    'MA50_Percent': indicators['ma50_percent'][i],
                    'NH_NL_Diff': indicators['nh_nl_diff'][i],
                    'Volume_Ratio': indicators['volume_ratio'][i],
                    'Advancing': indicators['advancing'][i],
                    'Declining': indicators['declining'][i],
                    'New_Highs': indicators['new_highs'][i],
                    'New_Lows': indicators['new_lows'][i]
                }
                csv_data.append(row)
            
            # A√±adir se√±ales actuales
            current_signals = {
                'Analysis_Date': analysis_result['analysis_date'],
                'Market_Bias': analysis_result['summary']['market_bias'],
                'Confidence': analysis_result['summary']['confidence'],
                'Strength_Score': analysis_result['summary']['strength_score']
            }
            
            for indicator, signal_data in signals.items():
                current_signals[f'{indicator}_signal'] = signal_data['signal']
                current_signals[f'{indicator}_strength'] = signal_data['strength']
            
            df = pd.DataFrame(csv_data)
            
            # Guardar CSV principal
            csv_path = "reports/market_breadth_analysis.csv"
            os.makedirs("reports", exist_ok=True)
            df.to_csv(csv_path, index=False)
            
            # Guardar se√±ales actuales
            signals_path = "reports/market_breadth_signals.csv"
            pd.DataFrame([current_signals]).to_csv(signals_path, index=False)
            
            print(f"‚úÖ CSV guardado: {csv_path}")
            print(f"‚úÖ Se√±ales guardadas: {signals_path}")
            
            return csv_path
            
        except Exception as e:
            print(f"‚ùå Error guardando CSV: {e}")
            return None


# ==============================================================================
# INTEGRACI√ìN CON TEMPLATES LIQUID GLASS
# ==============================================================================

class MarketBreadthHTMLGenerator:
    """Generador HTML con dise√±o Liquid Glass para Market Breadth"""
    
    def __init__(self, base_url="https://tantancansado.github.io/stock_analyzer_a"):
        self.base_url = base_url
    
    def generate_breadth_html(self, analysis_result):
        """Genera HTML con dise√±o Liquid Glass para Market Breadth"""
        if not analysis_result:
            return None
        
        summary = analysis_result['summary']
        signals = analysis_result['signals']
        indicators = analysis_result['indicators']
        breadth_data = analysis_result['breadth_data']
        timestamp = analysis_result['analysis_date']
        
        # CSS Liquid Glass espec√≠fico para Market Breadth
        liquid_css = self._get_breadth_liquid_css()
        
        html_content = f"""<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üìä Market Breadth Analysis | Liquid Glass Dashboard</title>
    <meta name="description" content="An√°lisis avanzado de amplitud de mercado con indicadores t√©cnicos">
    <style>
        {liquid_css}
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
</head>
<body>
    <div class="glass-container">
        <header class="liquid-header glass-card floating-element">
            <h1>üìä Market Breadth Analysis</h1>
            <p>An√°lisis completo de amplitud de mercado con 8 indicadores clave</p>
            <div class="market-status {summary['market_bias'].split()[1].lower()}">
                <div class="pulse-dot"></div>
                <span>{summary['bias_emoji']} {summary['market_bias']} ‚Ä¢ Confianza {summary['confidence']}</span>
            </div>
        </header>
        
        <section class="stats-liquid">
            <div class="stat-glass fade-in-up" style="animation-delay: 0.1s">
                <div class="stat-number">{summary['bullish_signals']}</div>
                <div class="stat-label">Se√±ales Alcistas</div>
            </div>
            <div class="stat-glass fade-in-up" style="animation-delay: 0.2s">
                <div class="stat-number">{summary['bearish_signals']}</div>
                <div class="stat-label">Se√±ales Bajistas</div>
            </div>
            <div class="stat-glass fade-in-up" style="animation-delay: 0.3s">
                <div class="stat-number">{summary['neutral_signals']}</div>
                <div class="stat-label">Se√±ales Neutrales</div>
            </div>
            <div class="stat-glass fade-in-up" style="animation-delay: 0.4s">
                <div class="stat-number">{summary['strength_score']}</div>
                <div class="stat-label">Puntuaci√≥n Fuerza</div>
            </div>
        </section>
        
        <main class="content-liquid glass-card">
            <h2 class="section-title">üéØ Indicadores de Amplitud</h2>
            
            <div class="indicators-grid">
                {self._generate_indicators_html(signals)}
            </div>
        </main>
        
        <section class="charts-section glass-card">
            <h2 class="section-title">üìà Gr√°ficos Interactivos</h2>
            <div class="charts-grid">
                <div class="chart-container">
                    <h3 class="chart-title">L√≠nea Avance-Declive</h3>
                    <canvas id="adLineChart"></canvas>
                </div>
                <div class="chart-container">
                    <h3 class="chart-title">Oscilador McClellan</h3>
                    <canvas id="mcclellanChart"></canvas>
                </div>
                <div class="chart-container">
                    <h3 class="chart-title">√çndice TRIN</h3>
                    <canvas id="trinChart"></canvas>
                </div>
                <div class="chart-container">
                    <h3 class="chart-title">% Acciones sobre MA50</h3>
                    <canvas id="ma50Chart"></canvas>
                </div>
            </div>
        </section>
        
        <section class="content-liquid glass-card">
            <h2 class="section-title">üí° Interpretaci√≥n de Se√±ales</h2>
            {self._generate_interpretation_html()}
        </section>
        
        <footer class="footer-liquid">
            <p>üìä Market Breadth Analysis ‚Ä¢ Powered by Advanced TA</p>
            <p>
                <a href="{self.base_url}">üè† Dashboard Principal</a> ‚Ä¢ 
                <a href="dj_sectorial.html">üìä DJ Sectorial</a> ‚Ä¢ 
                <a href="insider_trading.html">üèõÔ∏è Insider Trading</a>
            </p>
        </footer>
    </div>
    
    <script>
        // Datos para gr√°ficos
        const chartData = {json.dumps({
            'dates': breadth_data['dates'],
            'ad_line': indicators['ad_line'],
            'mcclellan': indicators['mcclellan'],
            'trin': indicators['trin'],
            'ma50_percent': indicators['ma50_percent']
        })};
        
        // Configuraci√≥n com√∫n de gr√°ficos
        const chartConfig = {{
            responsive: true,
            maintainAspectRatio: false,
            plugins: {{
                legend: {{ labels: {{ color: 'white' }} }}
            }},
            scales: {{
                x: {{ ticks: {{ color: 'white' }}, grid: {{ color: 'rgba(255,255,255,0.1)' }} }},
                y: {{ ticks: {{ color: 'white' }}, grid: {{ color: 'rgba(255,255,255,0.1)' }} }}
            }}
        }};
        
        // Inicializar gr√°ficos
        function initCharts() {{
            // A/D Line Chart
            new Chart(document.getElementById('adLineChart'), {{
                type: 'line',
                data: {{
                    labels: chartData.dates,
                    datasets: [{{
                        label: 'L√≠nea A/D',
                        data: chartData.ad_line,
                        borderColor: '#4ade80',
                        backgroundColor: 'rgba(74, 222, 128, 0.1)',
                        tension: 0.4
                    }}]
                }},
                options: chartConfig
            }});
            
            // McClellan Oscillator
            new Chart(document.getElementById('mcclellanChart'), {{
                type: 'line',
                data: {{
                    labels: chartData.dates,
                    datasets: [{{
                        label: 'McClellan',
                        data: chartData.mcclellan,
                        borderColor: '#fbbf24',
                        backgroundColor: 'rgba(251, 191, 36, 0.1)',
                        tension: 0.4
                    }}]
                }},
                options: chartConfig
            }});
            
            // TRIN Chart
            new Chart(document.getElementById('trinChart'), {{
                type: 'line',
                data: {{
                    labels: chartData.dates,
                    datasets: [{{
                        label: 'TRIN',
                        data: chartData.trin,
                        borderColor: '#f87171',
                        backgroundColor: 'rgba(248, 113, 113, 0.1)',
                        tension: 0.4
                    }}]
                }},
                options: chartConfig
            }});
            
            // MA50 Percent Chart
            new Chart(document.getElementById('ma50Chart'), {{
                type: 'line',
                data: {{
                    labels: chartData.dates,
                    datasets: [{{
                        label: '% sobre MA50',
                        data: chartData.ma50_percent,
                        borderColor: '#8b5cf6',
                        backgroundColor: 'rgba(139, 92, 246, 0.1)',
                        tension: 0.4
                    }}]
                }},
                options: chartConfig
            }});
        }}
        
        // Inicializar cuando carga la p√°gina
        window.addEventListener('load', initCharts);
        
        // Animaciones de entrada
        document.addEventListener('DOMContentLoaded', function() {{
            const elements = document.querySelectorAll('.fade-in-up');
            elements.forEach((el, index) => {{
                el.style.animationDelay = `${{index * 0.1}}s`;
            }});
        }});
        
        console.log('üìä Market Breadth Analysis - Liquid Glass Dashboard Loaded');
        console.log('üéØ Market Bias: {summary["market_bias"]}');
        console.log('üí™ Strength Score: {summary["strength_score"]}');
    </script>
</body>
</html>"""
        
        return html_content
    
    def _get_breadth_liquid_css(self):
        """CSS espec√≠fico para Market Breadth con dise√±o Liquid Glass"""
        return """
        /* Market Breadth Liquid Glass CSS */
        :root {
            --glass-primary: rgba(99, 102, 241, 0.9);
            --glass-secondary: rgba(139, 92, 246, 0.8);
            --glass-accent: rgba(59, 130, 246, 1);
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-bg-hover: rgba(255, 255, 255, 0.12);
            --glass-border: rgba(255, 255, 255, 0.15);
            --glass-shadow: 0 8px 32px rgba(0, 0, 0, 0.37);
            --text-primary: rgba(255, 255, 255, 0.95);
            --text-secondary: rgba(255, 255, 255, 0.75);
            --success: rgba(72, 187, 120, 0.9);
            --warning: rgba(251, 191, 36, 0.9);
            --danger: rgba(239, 68, 68, 0.9);
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            background: #020617;
            background-image: radial-gradient(ellipse at top, rgba(16, 23, 42, 0.9) 0%, rgba(2, 6, 23, 0.95) 50%, rgba(0, 0, 0, 0.98) 100%);
            background-attachment: fixed;
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        .glass-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .glass-card {
            background: var(--glass-bg);
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            box-shadow: var(--glass-shadow);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .glass-card:hover {
            background: var(--glass-bg-hover);
            transform: translateY(-4px);
        }
        
        .liquid-header {
            text-align: center;
            padding: 3rem 2rem;
            margin-bottom: 2rem;
        }
        
        .liquid-header h1 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 800;
            background: linear-gradient(135deg, var(--glass-primary), var(--glass-secondary));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
        }
        
        .market-status {
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1.5rem;
            border-radius: 50px;
            font-weight: 600;
            backdrop-filter: blur(10px);
            border: 1px solid;
        }
        
        .market-status.alcista {
            background: rgba(72, 187, 120, 0.1);
            border-color: rgba(72, 187, 120, 0.3);
            color: var(--success);
        }
        
        .market-status.bajista {
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.3);
            color: var(--danger);
        }
        
        .market-status.neutral {
            background: rgba(251, 191, 36, 0.1);
            border-color: rgba(251, 191, 36, 0.3);
            color: var(--warning);
        }
        
        .pulse-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse-glow 2s ease-in-out infinite;
        }
        
        .alcista .pulse-dot { background: #48bb78; box-shadow: 0 0 10px rgba(72, 187, 120, 0.8); }
        .bajista .pulse-dot { background: #ef4444; box-shadow: 0 0 10px rgba(239, 68, 68, 0.8); }
        .neutral .pulse-dot { background: #fbbf24; box-shadow: 0 0 10px rgba(251, 191, 36, 0.8); }
        
        @keyframes pulse-glow {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.3; transform: scale(1.2); }
        }
        
        .stats-liquid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }
        
        .stat-glass {
            background: var(--glass-bg);
            backdrop-filter: blur(16px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 2rem;
            text-align: center;
            transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .stat-glass:hover {
            transform: translateY(-12px) scale(1.05);
            box-shadow: 0 20px 60px rgba(99, 102, 241, 0.3);
        }
        
        .stat-number {
            font-size: 3rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--glass-accent), var(--glass-primary));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }
        
        .stat-label {
            color: var(--text-secondary);
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
        }
        
        .content-liquid {
            padding: 2.5rem;
            margin-bottom: 2rem;
        }
        
        .section-title {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 2rem;
            text-align: center;
            position: relative;
        }
        
        .section-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background: linear-gradient(90deg, var(--glass-primary), var(--glass-secondary));
            border-radius: 2px;
        }
        
        .indicators-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
        }
        
        .indicator-card {
            background: var(--glass-bg);
            backdrop-filter: blur(16px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 1.5rem;
            transition: all 0.4s ease;
        }
        
        .indicator-card:hover {
            transform: translateY(-4px);
            background: var(--glass-bg-hover);
        }
        
        .indicator-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .indicator-name {
            font-weight: 700;
            color: var(--text-primary);
        }
        
        .indicator-value {
            font-weight: 600;
            font-size: 1.1rem;
        }
        
        .indicator-signal {
            margin-bottom: 0.5rem;
        }
        
        .signal-strong { color: var(--success); }
        .signal-moderate { color: var(--warning); }
        .signal-weak { color: var(--text-secondary); }
        .signal-bearish { color: var(--danger); }
        
        .charts-section {
            padding: 2.5rem;
            margin-bottom: 2rem;
        }
        
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 2rem;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 16px;
            padding: 1.5rem;
            border: 1px solid var(--glass-border);
        }
        
        .chart-title {
            color: var(--glass-primary);
            font-weight: 600;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        canvas {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            height: 250px !important;
        }
        
        .floating-element {
            animation: float-gentle 6s ease-in-out infinite;
        }
        
        @keyframes float-gentle {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        .fade-in-up {
            opacity: 0;
            transform: translateY(30px);
            animation: fadeInUp 0.8s ease-out forwards;
        }
        
        @keyframes fadeInUp {
            to { opacity: 1; transform: translateY(0); }
        }
        
        .footer-liquid {
            text-align: center;
            margin-top: 4rem;
            padding: 2rem 0;
            border-top: 1px solid var(--glass-border);
            color: var(--text-secondary);
        }
        
        .footer-liquid a {
            color: var(--glass-accent);
            text-decoration: none;
            transition: all 0.3s ease;
        }
        
        .footer-liquid a:hover {
            color: var(--glass-primary);
            text-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
        }
        
        @media (max-width: 768px) {
            .glass-container { padding: 1rem; }
            .liquid-header { padding: 2rem 1rem; }
            .stats-liquid { grid-template-columns: repeat(2, 1fr); gap: 1rem; }
            .charts-grid { grid-template-columns: 1fr; }
            .indicators-grid { grid-template-columns: 1fr; }
        }
        """
    
    def _generate_indicators_html(self, signals):
        """Genera HTML para los indicadores"""
        html = ""
        
        indicator_configs = {
            'ad_line': {
                'name': 'L√≠nea Avance-Declive',
                'description': 'Tendencia de participaci√≥n del mercado'
            },
            'mcclellan': {
                'name': 'Oscilador McClellan',
                'description': 'Momentum de corto plazo'
            },
            'trin': {
                'name': '√çndice TRIN',
                'description': 'Presi√≥n compradora vs vendedora'
            },
            'ma50_percent': {
                'name': '% Acciones sobre MA50',
                'description': 'Fortaleza general del mercado'
            },
            'nh_nl_diff': {
                'name': 'Nuevos M√°ximos - M√≠nimos',
                'description': 'Confirmaci√≥n de tendencia'
            },
            'volume_ratio': {
                'name': 'Ratio Volumen',
                'description': 'Demanda vs oferta institucional'
            }
        }
        
        for indicator, config in indicator_configs.items():
            if indicator in signals:
                signal_data = signals[indicator]
                strength_class = self._get_strength_class(signal_data['signal'], signal_data['strength'])
                
                html += f"""
                <div class="indicator-card">
                    <div class="indicator-header">
                        <div class="indicator-name">{config['name']}</div>
                        <div class="indicator-value {strength_class}">{signal_data['value']:.2f}</div>
                    </div>
                    <div class="indicator-signal {strength_class}">
                        <strong>{signal_data['signal']}</strong>
                    </div>
                    <div class="indicator-strength">
                        Fuerza: {signal_data['strength']}
                    </div>
                    <div class="indicator-description">
                        {config['description']}
                    </div>
                </div>
                """
        
        return html
    
    def _get_strength_class(self, signal, strength):
        """Determina la clase CSS seg√∫n la se√±al y fuerza"""
        signal_lower = signal.lower()
        
        if any(word in signal_lower for word in ['alcista', 'fuerte', 'compradora', 'demanda']):
            return 'signal-strong'
        elif any(word in signal_lower for word in ['bajista', 'd√©bil', 'vendedora', 'debilidad']):
            return 'signal-bearish'
        elif strength.lower() == 'moderada':
            return 'signal-moderate'
        else:
            return 'signal-weak'
    
    def _generate_interpretation_html(self):
        """Genera HTML con interpretaci√≥n de se√±ales"""
        return """
        <div class="interpretation-grid">
            <div class="explanation-liquid">
                <h3>üéØ C√≥mo Interpretar las Se√±ales</h3>
                <ul>
                    <li><strong>üü¢ Se√±ales Alcistas:</strong> Indican fortaleza amplia del mercado y momentum positivo</li>
                    <li><strong>üî¥ Se√±ales Bajistas:</strong> Sugieren debilidad subyacente y presi√≥n vendedora</li>
                    <li><strong>üü° Se√±ales Neutrales:</strong> Mercado en equilibrio, esperar confirmaci√≥n direccional</li>
                </ul>
            </div>
            
            <div class="explanation-liquid">
                <h3>‚ö° Estrategias de Trading</h3>
                <ul>
                    <li><strong>Confluencia Alcista:</strong> 4+ indicadores alcistas = Sesgo comprador</li>
                    <li><strong>Divergencias:</strong> √çndices subiendo con breadth d√©bil = Precauci√≥n</li>
                    <li><strong>Extremos McClellan:</strong> >+100 o <-100 para timing de reversiones</li>
                    <li><strong>TRIN Extremo:</strong> <0.8 o >1.2 para confirmaci√≥n intraday</li>
                </ul>
            </div>
        </div>
        """


# ==============================================================================
# INTEGRACI√ìN CON EL SISTEMA PRINCIPAL
# ==============================================================================

# A√±adir al InsiderTradingSystem la nueva funcionalidad
def add_market_breadth_to_system():
    """
    Funci√≥n para a√±adir Market Breadth al sistema principal
    Se debe llamar desde el sistema principal
    """
    
    # Patch para a√±adir m√©todos al InsiderTradingSystem existente
    def run_market_breadth_analysis(self):
        """Ejecuta an√°lisis de amplitud de mercado"""
        print("\nüìä EJECUTANDO AN√ÅLISIS DE AMPLITUD DE MERCADO")
        print("=" * 60)
        
        try:
            analyzer = MarketBreadthAnalyzer()
            analysis_result = analyzer.run_breadth_analysis()
            
            if analysis_result:
                # Guardar CSV
                csv_path = analyzer.save_to_csv(analysis_result)
                
                # Generar HTML
                html_generator = MarketBreadthHTMLGenerator(self.github_uploader.base_url)
                html_content = html_generator.generate_breadth_html(analysis_result)
                
                if html_content:
                    html_path = "reports/market_breadth_report.html"
                    with open(html_path, 'w', encoding='utf-8') as f:
                        f.write(html_content)
                    print(f"‚úÖ HTML generado: {html_path}")
                    
                    return {
                        'analysis_result': analysis_result,
                        'html_path': html_path,
                        'csv_path': csv_path
                    }
                else:
                    print("‚ùå Error generando HTML")
                    return None
            else:
                print("‚ùå Error en an√°lisis")
                return None
                
        except Exception as e:
            print(f"‚ùå Error en an√°lisis de amplitud: {e}")
            traceback.print_exc()
            return None
    
    def upload_breadth_to_github_pages(self, breadth_results):
        """Sube an√°lisis de amplitud a GitHub Pages"""
        try:
            if not breadth_results:
                return None
            
            analysis_result = breadth_results['analysis_result']
            summary = analysis_result['summary']
            timestamp = analysis_result['analysis_date']
            
            title = f"üìä Market Breadth - {summary['market_bias']} - {timestamp}"
            description = f"An√°lisis de amplitud con {summary['bullish_signals']} se√±ales alcistas y {summary['bearish_signals']} bajistas"
            
            result = self.github_uploader.upload_report(
                breadth_results['html_path'],
                breadth_results['csv_path'],
                title,
                description
            )
            
            if result:
                print(f"‚úÖ Market Breadth subido a GitHub Pages: {result['github_url']}")
                return result
            else:
                print("‚ùå Error subiendo Market Breadth")
                return None
                
        except Exception as e:
            print(f"‚ùå Error subiendo Market Breadth: {e}")
            return None
    
    # Retornar los m√©todos para ser a√±adidos al sistema principal
    return {
        'run_market_breadth_analysis': run_market_breadth_analysis,
        'upload_breadth_to_github_pages': upload_breadth_to_github_pages
    }

if __name__ == "__main__":
    # Test independiente
    print("üß™ TESTING MARKET BREADTH ANALYZER")
    print("=" * 50)
    
    analyzer = MarketBreadthAnalyzer()
    result = analyzer.run_breadth_analysis()
    
    if result:
        print("\n‚úÖ Test completado exitosamente")
        
        # Test HTML generator
        html_gen = MarketBreadthHTMLGenerator()
        html = html_gen.generate_breadth_html(result)
        
        if html:
            with open("test_market_breadth.html", "w", encoding="utf-8") as f:
                f.write(html)
            print("‚úÖ HTML de prueba generado: test_market_breadth.html")
        
        # Test CSV
        csv_path = analyzer.save_to_csv(result)
        if csv_path:
            print(f"‚úÖ CSV de prueba generado: {csv_path}")
    else:
        print("‚ùå Test fallido")

    def _get_default_ad_with_source(self):
        """A-D Line por defecto con fuente"""
        return {
            'ad_line_value': 45200,
            'ad_ma50': 44800,
            'ad_trend': 'Neutral',
            'ad_change_5d': 0.5,
            'ad_change_20d': 1.0,
            'ad_signal': 'üü° Estimaci√≥n',
            'source': 'Valores estimados por defecto'
        }

    def _get_default_mcclellan_with_source(self):
        """McClellan por defecto con fuente"""
        return {
            'mcclellan_oscillator': 15.0,
            'mcclellan_ma10': 12.0,
            'mcclellan_summation': 250,
            'mcclellan_signal': 'üü° Neutral',
            'mcclellan_regime': 'Neutral',
            'source': 'Valores estimados por defecto'
        }

    def _get_default_arms_tick(self):
        """Arms & TICK por defecto"""
        return {
            'arms_index': 1.05,
            'arms_ma5': 1.08,
            'arms_signal': 'üü° Neutral',
            'tick_value': 25,
            'tick_average': 20,
            'tick_signal': 'üü° Ligeramente Positivo',
            'source': 'Valores por defecto'
        }

    def get_advance_decline_indicators(self):
        """
        Obtiene indicadores A-D Line CON SCRAPING MEJORADO + FALLBACKS
        """
        try:
            print("     üîÑ Obteniendo A-D Line con scraping...")
            
            # 1. Intentar scraping espec√≠fico A-D
            scrape_result = self.scrape_amplitud_mercado_robusto('ad_line')
            if scrape_result and scrape_result.get('ad_value'):
                ad_value = scrape_result['ad_value']
                trend = scrape_result.get('trend', 'Neutral')
                
                return {
                    'ad_line_value': int(ad_value),
                    'ad_ma50': int(ad_value * 0.98),  # Estimaci√≥n
                    'ad_trend': trend,
                    'ad_change_5d': np.random.uniform(0.5, 2.5),
                    'ad_change_20d': np.random.uniform(1.0, 4.0),
                    'ad_signal': self._interpret_ad_signal(trend, 2.0),
                    'source': scrape_result['source']
                }
            
            # 2. Calcular usando SPY como proxy (NO usar Yahoo Finance con tickers rotos)
            print("     üîÑ Calculando A-D usando SPY como proxy...")
            spy = yf.Ticker('SPY')  # Este S√ç funciona
            spy_data = spy.history(period='3mo')
            
            if not spy_data.empty:
                current_price = spy_data['Close'].iloc[-1]
                ma50 = spy_data['Close'].rolling(50).mean().iloc[-1] if len(spy_data) >= 50 else current_price
                trend = "Alcista" if current_price > ma50 else "Bajista"
                
                change_20d = ((current_price / spy_data['Close'].iloc[-21]) - 1) * 100 if len(spy_data) > 20 else 0
                # Escalar a valores t√≠picos de A-D Line
                ad_value = int(45000 + (change_20d * 150))
                
                return {
                    'ad_line_value': ad_value,
                    'ad_ma50': ad_value - 400,
                    'ad_trend': trend,
                    'ad_change_5d': change_20d / 4,
                    'ad_change_20d': change_20d,
                    'ad_signal': self._interpret_ad_signal(trend, change_20d),
                    'source': 'Calculado usando SPY proxy'
                }
            
            # 3. Fallback final
            print("     ‚ö†Ô∏è Usando valores estimados para A-D Line")
            return self._get_default_ad_with_source()
            
        except Exception as e:
            print(f"     ‚ùå Error general A-D Line: {e}")
            return self._get_default_ad_with_source()

    def get_mcclellan_indicators(self):
        """
        Obtiene McClellan CON SCRAPING MEJORADO + FALLBACKS
        """
        try:
            print("     üîÑ Obteniendo McClellan con scraping...")
            
            # 1. Intentar scraping espec√≠fico McClellan
            scrape_result = self.scrape_amplitud_mercado_robusto('mcclellan')
            if scrape_result and scrape_result.get('mcclellan_value'):
                mcl_value = scrape_result['mcclellan_value']
                regime = scrape_result.get('regime', 'Neutral')
                
                return {
                    'mcclellan_oscillator': round(mcl_value, 2),
                    'mcclellan_ma10': round(mcl_value * 0.9, 2),
                    'mcclellan_summation': round(mcl_value * 15, 0),
                    'mcclellan_signal': self._interpret_mcclellan_signal(mcl_value),
                    'mcclellan_regime': regime,
                    'source': scrape_result['source']
                }
            
            # 2. Calcular usando VIX como proxy inverso (NO usar Yahoo Finance con tickers rotos)
            print("     üîÑ Calculando McClellan usando VIX como proxy...")
            vix = yf.Ticker('^VIX')  # Este S√ç funciona
            vix_data = vix.history(period='1mo')
            
            if not vix_data.empty:
                current_vix = vix_data['Close'].iloc[-1]
                # McClellan aproximado: VIX bajo = McClellan positivo
                approx_mcclellan = (22 - current_vix) * 2.5
                # Limitar a rango realista
                approx_mcclellan = max(-150, min(150, approx_mcclellan))
                regime = 'Alcista' if approx_mcclellan > 0 else 'Bajista'
                
                return {
                    'mcclellan_oscillator': round(approx_mcclellan, 2),
                    'mcclellan_ma10': round(approx_mcclellan * 0.8, 2),
                    'mcclellan_summation': round(approx_mcclellan * 20, 0),
                    'mcclellan_signal': self._interpret_mcclellan_signal(approx_mcclellan),
                    'mcclellan_regime': regime,
                    'source': f'Calculado usando VIX {current_vix:.2f} como proxy'
                }
            
            # 3. Fallback final
            print("     ‚ö†Ô∏è Usando valores estimados para McClellan")
            return self._get_default_mcclellan_with_source()
            
        except Exception as e:
            print(f"     ‚ùå Error general McClellan: {e}")
            return self._get_default_mcclellan_with_source()

    def get_arms_tick_indicators(self):
        """
        Obtiene TRIN y TICK usando PROXY CALCULATIONS (NO Yahoo Finance)
        """
        try:
            print("     üîÑ Obteniendo TRIN y TICK...")
            
            indicators = {}
            
            # 1. Calcular TRIN usando vol√∫menes de ETFs (NO usar Yahoo Finance con tickers rotos)
            print("     üîÑ Calculando TRIN usando vol√∫menes ETFs...")
            try:
                etfs_data = {}
                for symbol in ['SPY', 'QQQ', 'IWM']:  # Estos S√ç funcionan
                    ticker = yf.Ticker(symbol)
                    data = ticker.history(period='5d')
                    if not data.empty:
                        etfs_data[symbol] = data
                
                if etfs_data:
                    # Calcular TRIN aproximado basado en vol√∫menes relativos
                    total_vol_ratio = 0
                    total_price_change = 0
                    count = 0
                    
                    for symbol, data in etfs_data.items():
                        if len(data) >= 2:
                            vol_ratio = data['Volume'].iloc[-1] / data['Volume'].mean()
                            price_change = (data['Close'].iloc[-1] / data['Close'].iloc[-2] - 1) * 100
                            total_vol_ratio += vol_ratio
                            total_price_change += price_change
                            count += 1
                    
                    if count > 0:
                        avg_vol_ratio = total_vol_ratio / count
                        avg_price_change = total_price_change / count
                        
                        # TRIN aproximado: si precios bajan y volumen sube = TRIN alto
                        if avg_price_change < 0:
                            approx_trin = 1.0 + (avg_vol_ratio - 1) * 0.4
                        else:
                            approx_trin = max(0.6, 1.0 - (avg_price_change * 0.08))
                        
                        approx_trin = max(0.4, min(3.5, approx_trin))  # Limitar rango
                        
                        indicators.update({
                            'arms_index': round(approx_trin, 2),
                            'arms_ma5': round(approx_trin * 1.03, 2),
                            'arms_signal': self._interpret_arms_signal(approx_trin),
                            'source_trin': 'Calculado usando vol√∫menes ETFs'
                        })
                        print(f"     ‚úÖ TRIN calculado: {approx_trin:.2f}")
                        
            except Exception as e:
                print(f"     ‚ùå Error calculando TRIN: {e}")
            
            # 2. Calcular TICK usando breadth de ETFs
            print("     üîÑ Calculando TICK usando breadth ETFs...")
            try:
                etfs = ['SPY', 'QQQ', 'IWM', 'DIA']  # Estos S√ç funcionan
                up_count = 0
                down_count = 0
                total_change = 0
                
                for etf in etfs:
                    ticker = yf.Ticker(etf)
                    data = ticker.history(period='2d')
                    
                    if len(data) >= 2:
                        change = (data['Close'].iloc[-1] / data['Close'].iloc[-2] - 1) * 100
                        total_change += change
                        
                        if change > 0:
                            up_count += 1
                        else:
                            down_count += 1
                
                # TICK aproximado basado en net breadth
                net_breadth = up_count - down_count
                avg_change = total_change / len(etfs) if len(etfs) > 0 else 0
                
                # Escalar a rango t√≠pico de TICK
                approx_tick = net_breadth * 200 + (avg_change * 40)
                approx_tick = max(-1200, min(1200, approx_tick))  # Limitar rango
                
                indicators.update({
                    'tick_value': round(approx_tick, 0),
                    'tick_average': round(approx_tick * 0.75, 0),
                    'tick_signal': self._interpret_tick_signal(approx_tick),
                    'source_tick': 'Calculado usando breadth ETFs'
                })
                
                print(f"     ‚úÖ TICK calculado: {approx_tick:.0f}")
                
            except Exception as e:
                print(f"     ‚ùå Error calculando TICK: {e}")
            
            # 3. Fallbacks finales si todo falla
            if 'arms_index' not in indicators:
                indicators.update({
                    'arms_index': 1.05,
                    'arms_ma5': 1.08,
                    'arms_signal': 'üü° Neutral',
                    'source_trin': 'Valor neutral estimado'
                })
                print("     ‚ö†Ô∏è TRIN: Usando valor neutral")
            
            if 'tick_value' not in indicators:
                indicators.update({
                    'tick_value': 25,
                    'tick_average': 20,
                    'tick_signal': 'üü° Ligeramente Positivo',
                    'source_tick': 'Valor neutral estimado'
                })
                print("     ‚ö†Ô∏è TICK: Usando valor neutral")
            
            # Combinar fuentes
            trin_source = indicators.get('source_trin', 'desconocido')
            tick_source = indicators.get('source_tick', 'desconocido')
            indicators['source'] = f"TRIN: {trin_source} | TICK: {tick_source}"
            
            print(f"     ‚úÖ RESULTADO - TRIN: {indicators['arms_index']:.2f} | TICK: {indicators['tick_value']:.0f}")
            
            return indicators
            
        except Exception as e:
            print(f"     ‚ùå Error general Arms/TICK: {e}")
            return self._get_default_arms_tick()

    def scrape_amplitud_mercado_robusto(self, indicator_type):
        """Scraping S√öPER ROBUSTO de amplitudmercado.com - VERSI√ìN ARREGLADA"""
        try:
            # URLs espec√≠ficas para cada indicador
            urls_map = {
                'ad_line': 'https://amplitudmercado.com/nyse/ad',
                'mcclellan': 'https://amplitudmercado.com/nyse/mcclellan', 
                'summation': 'https://amplitudmercado.com/nyse/summation',
                'new_highs_lows': 'https://amplitudmercado.com/nyse/maxmin',
                'rasi': 'https://amplitudmercado.com/nyse/rasi',
                'general': 'https://amplitudmercado.com/nyse'
            }
            
            # Intentar m√∫ltiples URLs para el indicador
            urls_to_try = []
            if indicator_type in urls_map:
                urls_to_try.append(urls_map[indicator_type])
            urls_to_try.append(urls_map['general'])  # Fallback al general
            
            for url in urls_to_try:
                print(f"     üîÑ Intentando scraping: {url}")
                
                try:
                    # Realizar petici√≥n con timeout largo
                    response = self.session.get(url, timeout=30, allow_redirects=True)
                    
                    if response.status_code == 200:
                        content = response.text
                        print(f"     ‚úÖ P√°gina obtenida: {len(content)} caracteres")
                        
                        # Intentar extraer datos usando m√∫ltiples m√©todos
                        extracted_data = self._parse_amplitud_html_avanzado(content, indicator_type, url)
                        
                        if extracted_data and extracted_data.get('success'):
                            print(f"     üéØ DATOS EXTRA√çDOS: {extracted_data}")
                            return extracted_data
                        else:
                            print(f"     ‚ö†Ô∏è No se pudieron extraer datos espec√≠ficos de {url}")
                            
                    else:
                        print(f"     ‚ùå Error HTTP {response.status_code} en {url}")
                        
                except requests.exceptions.Timeout:
                    print(f"     ‚è∞ TIMEOUT en {url}")
                    continue
                except requests.exceptions.RequestException as e:
                    print(f"     üåê ERROR CONEXI√ìN en {url}: {e}")
                    continue
                    
            print("     ‚ùå No se pudo obtener datos de ninguna URL")
            return None
            
        except Exception as e:
            print(f"     ‚ùå ERROR GENERAL en scraping: {e}")
            return None